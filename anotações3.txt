- HASHING ABERTO:
    
    inicializarHash(tabela):
        for (i < numEntradas) [i] = NULL
    
    funcaoHashing(num)
    inserirHash(tabela, num)
    mostrarHash(tabela, num)
    Hash* localizarHash(tabela, num)
    excluirHash(tabela, num)
    liberarMemoria(tabela)

- HASHING FECHADO:
    
    int i=0;
    int pos = hashing;
    while(i < tam && tabela[(pos+i)%tam]...)
    (pos+i)%tam -> evita que acesse área inacessível do vetor
                   se o i passar de tam.
    if (i < tam)

- HASHING FECHADO QUADRATICO:

    mesmo modo que o fechado

    ponto principal:
        while (k < tam && tabela[pos]...){
            pos = (pos+k)%tam;
            k = k+1;
        }

- GRAFOS MATRIZ:
    procurarCaminho(adj, k, a, b)
        caso base:
            k == 1 -> return adjacente(a, b)
        caso recursivo:
            for (c=0...)
                if (adjacente(a, c) && procurarCaminho(k-1, c, b))

- GRAFOS ENCADEADOS NO VETOR:

    1. inicializarGrafo
    2. criaListaDeNodosVazios
    3. getnode
    4. freenode
    5. joinwt
    6. join
    7. remv
    8. remvwt
    9. adjacent
    10. findnode
    11. addnode
    12. remvnode
        atual, anterior, retorno;
        aux, aux2, auxNode;
        atual = anterior = *graph;
        - while (atual >= 0):
            - achou o vertice?:
                - primeiro?:
                    - ajeita
                - exclui os arcos:
                    while, aux2 = aux, aux = node[aux].next, freenode(aux2);
                - freenode
                - retorno 1
            - nao é o vertice?:
                - acessa os arcos
                - aponta para p?
                    - é o primeiro?
                        node[p].point = node[aux].next;
                    - não?
                        node[aux2].next = node[aux].next;
                    - atualiza aux, aux2 e (auxNode?)
                    - freenode(aux2 ou auxNode)
                    






