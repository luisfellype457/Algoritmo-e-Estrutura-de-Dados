- FILA SEQUENCIAL:

    (F = (F+1) % MAX)

    criar_fila(*f)
    eh_vazia(*f)
    ins(*f, v)
    cons(*f)
    ret(*f)
    cons_ret(*f)

    inserção:
        if f->N == MAX

    retirada:
        if eh_vazia

    cons_ret:
        if eh_vazia


- FILA ENCADEADA:

    (DESCRITOR)

    criar_fila(*f):
        alocar memória, inicio/fim = NULL
    eh_vazia(f)
    ins(f, v)
    cons(f)
    ret(f)
    cons_ret(f)
    destruir(f)

    inserção:
        alocar memória (novo)
        if eh_vazia:
            inicio = novo
        else:
            fim->next = novo
        fim = novo

    retirada:
        if eh_vazia
        aux = inicio
        inicio = aux->next
        if inicio == NULL:
            fim = NULL
        free(aux)

    cons_ret:
        mesmo processo retidada
        porém guarda aux->inf
    
    destruir:
        { aux = inicio
          inicio = aux->next
          free(aux) }   // limpa a fila
        free(f)   // limpa o descritor


- PILHA SEQUENCIAL:
    
    (TOPO)

    criar_pilha(*p)
    eh_vazia(*p)
    push(*p, v)
    top(*p)
    pop(*p)
    top_pop(*p)
    inverter_fila(*f)     // usando pilha

    inserção:
        if TOPO == MAX-1
        p->val[++p->TOPO] = v

    retirada:
        if eh_vazia
        p->TOPO--

    inverter_fila:
        cria a pilha
        enquanto a fila não é vazia:
            insere os elementos na pilha
            primeiro -> último
        enquanto a pilha não é vazia:
            insere os elementos na fila
            último -> primeiro


- PILHA ENCADEADA:

    (lista encadeada invertida)

    create(*p)    // ficou em inglês(?)
    is_empty(p)
    push(*p, v)
    top(p)
    pop(*p)
    top_pop(*p)
    destroy(p)

    inserção:
        aloca memória (new)
        new->next = *p
        *p = new

    retirada:
        if (!*p) ou if (eh_vazia)
        aux = *p
        *p = aux->next
        free(aux)

    top_pop:
        mesmo que retirada mas v = aux->inf

    destroy:
        aux = p
        p = p->next
        free(aux)


- ÁRVORE BINÁRIA SEQUENCIAL:

    maketree(*t, x)
    - getNode(*t)
    - freeNode(*t, node)
    setleft(*t, p, x)
    setright(*t)
    info(*t, p)
    left(*t, p)
    right(*t, p)
    father(*t, p)
    brother(*t, p)
    isleft(*t, p)
    isright(*t, p)


- ÁRVORE BINÁRIA ENCADEADA:

    maketree(*t, x) // aloca memória
    setleft(t, x) // aloca t->left
    setright(t, x) // aloca t->right
    info(t)
    left(t)
    right(t)
    father(t)
    brother(t)
    isleft(t)
    isright(t)
    
    percursoEmLargura(t):
        fila de árvores
    percursoPreOrdem(t)
    percursoInOrdem(t)
    percursoPosOrdem(t)


- ÁRVORE BINÁRIA DE BUSCA:
    
    ARV_BIN_ENC -> ARB_BIN_BUSCA

    ins_ele(*arv, v):
        if(!*arv)
        cria ponteiro tmp = *arv
        do/while(1)
        compara tmp->info com v

    remocaoPorFusao(*arvore):
        verifica se existe *arvore
        cria ponteiro tmp = *arvore
        1 - sem nó direito
        2 - sem nó esquerdo
        3 - com os dois nós:
            desce para a esquerda
            desce todas para a direita
            faz a fusão
        free(tmp)

    remocaoPorCopia(*arvore):
        mesmo procedimento
        1 - //
        2 - //
        3 - com dois nós:
            desce para a direita
            desce todas para a esquerda
            copia o valor
            if (tmp->father == *arvore):
                (*arvore)->right = tmp->right
            else:
                tmp->father->left = tmp->right
        free(tmp)


- ÁRVORE AVL:

    
